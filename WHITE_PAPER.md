# **Tesseract Vault: Formally Verified Post-Quantum Cryptography Through AI-Orchestrated Development**

**Author:** Doll

**Date:** January 5, 2026

**Version:** 1.6.0

**Status:** Formally Verified / NIST FIPS 203/204 Compliant / Wycheproof Validated

**Project Link:** [github.com/dollspace-gay/Tesseract-Vault](https://github.com/dollspace-gay/Tesseract-Vault)

**Methodology:** Verification-Driven Development (VDD) via Iterative Adversarial Refinement

---

## **1. Abstract**

This paper documents the evolution of **Tesseract Vault**, a Rust-based encryption suite implementing both classical and post-quantum cryptography. The project transitioned from a functional single-file script generated by **Gemini 2.5 Pro** into a production-hardened, formally verified system with **996 unit tests**, mathematical proofs of safety via **Kani** and **Prusti**, and compliance with NIST cryptographic standards including **FIPS 203** (ML-KEM) and **FIPS 204** (ML-DSA).

The development was orchestrated by **Claude Sonnet** and **Claude Opus 4.5**, utilizing an "Adversarial Spiral" methodology where formal verification failures and automated security scanning drove iterative refinement. A key innovation is the **Adversarial Security Loop**—iterating between AI-powered security scanning and AI-driven remediation until the scanner produces mostly false positives, indicating exhaustion of genuine vulnerabilities. This represents a paradigm shift from "writing code" to "defining and satisfying mathematical constraints."

---

## **2. The Evolution: From One-Shot to Formal Proof**

### **Phase I: The Seed (Gemini 2.5 Pro)**

The project began as an experiment: *Can a state-of-the-art LLM generate a working encryption tool in a single prompt?*

* **Input:** A prompt requesting AES-256-GCM file encryption with Argon2 key derivation
* **Model:** Gemini 2.5 Pro
* **Result:** A functional 400-line single-file Rust tool ([original source](https://raw.githubusercontent.com/dollspace-gay/Tesseract-Vault/83519422c2e21456c334f4cc20a34323630a414e/src/main.rs)). While syntactically correct, it lacked modular architecture, formal verification, and advanced security features.

### **Phase II: The Adversarial Spiral (Claude Sonnet/Opus)**

A two-month refinement period transformed the prototype into a production system. Claude was used not merely to write code, but to **mediate feedback from formal verification engines**.

**Development Process:**
1. **Modularization:** Decomposing into discrete modules (`crypto/`, `volume/`, `hsm/`, `memory/`, `daemon/`) to isolate the Trusted Computing Base
2. **Formal Interrogation:** Running code through **Kani** (symbolic execution) and **Prusti** (SMT-based proofs)
3. **Constraint-Driven Refactoring:** Every Kani harness failure was fed back to Claude for resolution
4. **Test-Driven Hardening:** Adding Wycheproof, NIST CAVP, and NIST PQC test vectors

---

## **3. Cryptographic Architecture**

### **3.1 Symmetric Encryption**

| Algorithm | Purpose | Key Size | Standard |
|-----------|---------|----------|----------|
| **AES-256-GCM** | File/stream encryption | 256-bit | NIST SP 800-38D |
| **ChaCha20-Poly1305** | Alternative AEAD | 256-bit | RFC 8439 |
| **XTS-AES-256** | Volume sector encryption | 512-bit (2×256) | IEEE 1619 |

### **3.2 Key Derivation**

| Algorithm | Parameters | Standard |
|-----------|------------|----------|
| **Argon2id** | m=65536 KB, t=3, p=4 (default) | RFC 9106 / OWASP |
| **HKDF-SHA256** | Hybrid PQC key combination | RFC 5869 |
| **BLAKE3** | Fast hashing, key derivation | — |

### **3.3 Post-Quantum Cryptography**

Tesseract Vault implements NIST's finalized post-quantum standards:

| Algorithm | Purpose | Security Level | Standard |
|-----------|---------|----------------|----------|
| **ML-KEM-1024** | Key encapsulation | NIST Level 5 | **FIPS 203** (Aug 2024) |
| **ML-DSA-44/65/87** | Digital signatures | Levels 2/3/5 | **FIPS 204** (Aug 2024) |

**Key Sizes (FIPS 203 Compliant):**
- Encapsulation key: 1,568 bytes
- Decapsulation key: 3,168 bytes
- Ciphertext: 1,568 bytes
- Shared secret: 32 bytes

**Signature Sizes (FIPS 204 Compliant):**
- ML-DSA-44: 2,420 bytes
- ML-DSA-65: 3,309 bytes
- ML-DSA-87: 4,627 bytes

### **3.4 Hybrid Mode**

Post-quantum keys are combined with classical keys using HKDF:
```
final_key = HKDF-SHA256(classical_key || pqc_shared_secret, salt, info)
```
This provides defense-in-depth: security holds if *either* algorithm remains unbroken.

---

## **4. Hardware Security Integration**

### **4.1 TPM 2.0 Support**

Full TPM 2.0 integration for hardware-bound key protection:

| Feature | Description |
|---------|-------------|
| **Key Sealing** | Bind encryption keys to PCR values |
| **PCR Policies** | PCR 0-7 (boot chain), PCR 7 (Secure Boot) |
| **HMAC Challenge** | TPM-based key derivation |
| **Lockout Protection** | Hardware-enforced rate limiting |

**Supported Platforms:**
- Windows: TBS (TPM Base Services)
- Linux: tpm2-tss / /dev/tpm0

### **4.2 YubiKey Integration**

HMAC-SHA1 challenge-response for two-factor encryption:
- Slot 1/2 configuration support
- Challenge derivation from password
- Hardware-enforced key generation

---

## **5. Volume Container System**

### **5.1 Encrypted Volumes**

FUSE/WinFSP-based encrypted filesystem containers:

| Feature | Specification |
|---------|---------------|
| **Block Size** | 4,096 bytes |
| **Encryption** | XTS-AES-256 (sectors) |
| **Filesystem** | Custom inode-based (ext2-like) |
| **Journaling** | Write-ahead log for crash recovery |

### **5.2 Hidden Volumes**

Plausible deniability through hidden volume support:
- Hidden volume offset calculated from secondary password
- Indistinguishable from random data without correct passphrase
- Outer volume remains functional

### **5.3 Duress Password (Coercion Protection)**

A secondary "duress" password triggers secure key destruction instead of decryption:

| Feature | Behavior |
|---------|----------|
| **Normal Password** | Decrypts and mounts volume |
| **Duress Password** | Securely wipes master key, returns "decryption failed" |
| **Detection** | Impossible to distinguish from incorrect password |
| **Key Destruction** | Cryptographic erasure (overwrite + zeroize) |

**Implementation:**
- Duress password stored as separate Argon2id-derived key slot
- On match: destroys all key material before returning error
- Constant-time comparison prevents timing attacks
- No forensic evidence of duress activation

Use case: Coerced decryption scenarios (border crossings, legal compulsion) where revealing the real password is dangerous.

### **5.4 Remote Wipe**

Cloud-synchronized emergency wipe capability:
- HMAC-authenticated wipe tokens
- Replay protection via monotonic counters
- Secure key destruction on trigger

---

## **6. Verification Stack**

### **6.1 Formal Verification (Kani)**

Symbolic execution proves properties for *all possible inputs*:

| Harness | Property Verified |
|---------|-------------------|
| `verify_nonce_uniqueness_different_indices` | No nonce reuse across chunks |
| `verify_counter_injection` | Counter properly embedded in nonce |
| `verify_nonce_structure` | Correct nonce format (96-bit) |
| `verify_sequential_nonce_uniqueness` | Sequential nonces never collide |
| `verify_zero_index_valid` | Edge case: first chunk |
| `verify_max_index_valid` | Edge case: maximum chunk index |
| `verify_config_default_matches_constants` | Configuration consistency |
| `verify_no_parameter_overflow` | No integer overflow in parameters |

**Critical Achievement:** Nonce uniqueness is *mathematically proven* for the streaming encryption system. Nonce reuse in AES-GCM is catastrophic (enables key recovery), making this verification essential.

### **6.2 Formal Verification (Prusti)**

SMT-based verification with Z3 solver:

```toml
[prusti]
check_overflows = true
check_panics = true
check_arithmetic_overflow = true
check_bounds = true
check_null_dereference = true
verification_timeout = 120
solver = "z3"
```

### **6.3 Test Suites**

| Suite | Tests | Coverage |
|-------|-------|----------|
| **Unit Tests** | 996 | Core library |
| **Wycheproof** | 500+ | AES-GCM edge cases |
| **NIST CAVP** | 100+ | AES-256-GCM validation |
| **NIST PQC** | 30 | ML-KEM/ML-DSA per FIPS 203/204 |
| **Differential** | Property-based | Cross-implementation consistency |
| **DudeCT** | Statistical | Constant-time verification |

### **6.4 Constant-Time Verification**

DudeCT statistical analysis proves absence of timing leaks:
- Password comparison
- HMAC verification
- Key comparison operations

Threshold: t-value < 4.5 indicates no detectable timing leak.

---

## **7. Comparative Analysis**

| Feature | Original (One-Shot) | Current (v1.5.0) |
|---------|---------------------|------------------|
| **Lines of Code** | ~400 | 30,000+ |
| **Architecture** | Single file | Modular (15+ modules) |
| **Algorithms** | AES-GCM only | AES-GCM, ChaCha20, XTS-AES, ML-KEM, ML-DSA |
| **Verification** | Manual testing | Kani + Prusti formal proofs |
| **Test Vectors** | None | Wycheproof, NIST CAVP, NIST PQC |
| **Side-Channel** | Unknown | DudeCT validated |
| **Hardware Security** | None | TPM 2.0, YubiKey |
| **Volume Encryption** | None | FUSE/WinFSP containers |
| **Post-Quantum** | None | FIPS 203/204 compliant |
| **Platforms** | Linux only | Windows, Linux, WebAssembly |

---

## **8. Memory Safety**

### **8.1 Zeroization**

All sensitive data implements `Zeroizing<T>` wrapper:
- Automatic scrubbing on drop
- Compiler barrier prevents optimization
- Verified with pattern-based scrubbing

### **8.2 Memory Locking**

Platform-specific memory protection:
- Linux: `mlock()` prevents swapping
- Windows: `VirtualLock()` equivalent
- Encrypted memory pool for PQC operations

### **8.3 Secure Allocation**

Custom allocator with security features:
- Guard pages around sensitive allocations
- Memory scrubbing before deallocation
- Statistics tracking for audit

---

## **9. CI/CD Pipeline**

Automated verification on every commit:

| Workflow | Frequency | Purpose |
|----------|-----------|---------|
| `kani.yml` | Every PR | Formal verification |
| `coverage.yml` | Every PR | Code coverage (target: 80%+) |
| `dudect.yml` | Weekly | Timing analysis |
| `differential-testing.yml` | Weekly | Cross-implementation tests |
| `fuzz.yml` | Continuous | Fuzzing via OSS-Fuzz/ClusterFuzzLite |
| `cargo-deny.yml` | Every PR | Dependency audit |

---

## **10. Adversarial Security Loop**

### **10.1 Methodology Overview**

The Adversarial Security Loop is a novel security hardening technique that pits AI-powered security analysis against AI-driven code remediation in an iterative cycle. The process continues until the security scanner reaches a "confabulation threshold"—producing only false positives, indicating exhaustion of genuine vulnerabilities.

**Adversary Tool:** [CodeScanner](https://github.com/dollspace-gay/codescanner)

CodeScanner is an AI-powered security analysis tool that performs deep semantic analysis of Rust codebases, identifying vulnerabilities mapped to CWE (Common Weakness Enumeration) classifications. Unlike traditional static analyzers, it understands security context and can identify subtle issues like cryptographic misuse, memory safety violations, and authentication bypasses.

### **10.2 Loop Execution**

```
┌─────────────────────────────────────────────────────────────────┐
│                    ADVERSARIAL SECURITY LOOP                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌──────────────┐         ┌──────────────┐                     │
│   │  CodeScanner │ ──────► │ Vulnerability │                    │
│   │  (Gemini 3)  │         │    Report     │                    │
│   └──────────────┘         └───────┬───────┘                    │
│          ▲                         │                            │
│          │                         ▼                            │
│   ┌──────┴───────┐         ┌──────────────┐                     │
│   │   Codebase   │ ◄────── │ Claude Opus  │                     │
│   │   (Rust)     │         │   (Fixes)    │                     │
│   └──────────────┘         └──────────────┘                     │
│                                                                 │
│   Loop terminates when: Scanner produces >75% false positives   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Process:**
1. **Scan:** CodeScanner analyzes the codebase, producing vulnerability reports with CWE classifications
2. **Triage:** Claude Opus evaluates each finding, distinguishing genuine vulnerabilities from false positives via source code verification
3. **Fix:** Genuine vulnerabilities are remediated with proper security patterns
4. **Verify:** Tests are run to ensure fixes don't break functionality
5. **Repeat:** The loop continues until the scanner confabulates

### **10.3 Results: January 2026 Security Audit**

The most recent adversarial loop (January 5, 2026) processed **33 reported vulnerabilities** across 4 severity levels:

| Severity | Reported | Genuine | False Positive | Fix Rate |
|----------|----------|---------|----------------|----------|
| CRITICAL | 4 | 4 | 0 | 100% |
| HIGH | 5 | 2 | 3 | 100% |
| MEDIUM | 16 | 2 | 14 | 100% |
| LOW | 8 | 0 | 8 | N/A |
| **Total** | **33** | **8** | **25** | **100%** |

**Genuine Vulnerabilities Fixed:**

| CWE | Issue | Fix |
|-----|-------|-----|
| CWE-329 | Nonce reuse in EncryptedAllocation::write | Fresh nonce per write, prepended to ciphertext |
| CWE-345 | Unauthenticated remote wipe commands | Added freshness + nonce replay validation |
| CWE-287 | Wrong password for hidden volume mount | Corrected password routing |
| CWE-327 | AWS SigV4 using BLAKE3 instead of HMAC-SHA256 | Proper SHA-256 and HMAC-SHA256 per AWS spec |
| CWE-79 | CSP injection via tab/whitespace | char::is_whitespace() filtering |
| CWE-770 | Memory exhaustion via pq_metadata_size | Size validation before allocation |
| CWE-316 | MountOptions password not zeroized | Drop impl with zeroization |

### **10.4 Confabulation Examples**

When the scanner reaches exhaustion, it produces "confabulated" findings—issues that appear security-relevant but are actually false positives:

| Reported Issue | Why It's a False Positive |
|----------------|---------------------------|
| "Deprecated RNG API `rand::rng()`" | `rand::rng()` is the NEW API in rand 0.9+; `thread_rng()` is deprecated |
| "Hardcoded password in test" | Test code requires deterministic values for reproducibility |
| "HMAC-SHA1 in YubiKey module" | YubiKey hardware uses HMAC-SHA1—it's the device protocol, not our choice |
| "SSRF via S3 endpoint URL" | Admin-configured endpoints are trusted by definition |
| "DoS via mutex `.unwrap()`" | Standard Rust pattern; poisoned mutex indicates existing bug |
| "Silent fallback on mlock failure" | Intentional graceful degradation for containers/restricted environments |

### **10.5 Termination Criteria**

The loop terminates when:
- **>75% false positive rate:** Scanner is confabulating more than finding real issues
- **No CRITICAL/HIGH genuine findings:** Remaining issues are LOW or informational
- **Circular findings:** Scanner re-reports issues that were already triaged as false positives

This methodology provides **empirical evidence of security exhaustion**—not just absence of known vulnerabilities, but demonstrated inability of adversarial AI to find more.

### **10.6 Ongoing Security Maintenance**

**Important:** Reaching a high confabulation threshold does not mean the codebase is permanently secure. The adversarial security loop must be re-run before each new release for several reasons:

1. **New Code Introduction:** Any new features, refactoring, or dependency updates can introduce vulnerabilities that didn't exist during the previous audit cycle.

2. **Scanner Evolution:** AI security scanners improve over time. A scanner that previously confabulated on certain patterns may develop genuine detection capabilities in newer versions.

3. **Emerging Threat Classes:** New vulnerability classes and attack techniques are discovered continuously. What was considered secure practice yesterday may be vulnerable to attacks discovered today.

4. **Dependency Vulnerabilities:** Upstream dependencies may receive security advisories that affect your codebase, even if your code hasn't changed.

5. **Context Drift:** The security context of the application may change—new deployment environments, integration points, or threat models can expose previously-acceptable code as vulnerable.

**Recommended Cadence:**
- **Pre-release:** Full adversarial loop before any version bump
- **Major features:** Loop after significant new functionality
- **Quarterly:** Scheduled re-audit even without code changes (scanner/threat evolution)
- **Post-incident:** Immediate loop after any security disclosure in dependencies

The confabulation threshold from a previous audit provides a *baseline*, not a *guarantee*. Security is a continuous process, not a destination.

---

## **11. WebAssembly Support**

Browser-compatible encryption:

| Profile | Features | Size |
|---------|----------|------|
| `wasm-minimal` | AES-GCM + Argon2 | ~200 KB |
| `wasm-full` | + PQC + Compression | ~800 KB |

Optimizations:
- `wasm-opt -O4` with bulk-memory
- SIMD acceleration where available
- Web Crypto API integration for RNG

---

## **12. Conclusion: The "Orchestrator" Framework**

Tesseract Vault demonstrates that in 2026, developer value lies not in initial code generation but in **verification pipeline design**. The two-month refinement period represents a paradigm shift:

**From:** "Writing code that works"
**To:** "Defining constraints that code must satisfy"

By refusing to trust AI output without formal verification, we produced a cryptographic library that:
1. **Exceeds** security standards of manually-authored alternatives
2. **Proves** critical properties mathematically (not just tests)
3. **Implements** cutting-edge post-quantum cryptography
4. **Integrates** hardware security modules
5. **Passes** industry-standard test vectors (Wycheproof, NIST)

The "Adversarial Spiral" methodology—using formal verification failures as prompts for AI refinement—represents a reproducible framework for high-assurance software development.

---

## **13. Artifacts & Evidence**

* **Original One-Shot:** [Source Link](https://raw.githubusercontent.com/dollspace-gay/Tesseract-Vault/83519422c2e21456c334f4cc20a34323630a414e/src/main.rs)
* **Verified Repository:** [Tesseract Vault GitHub](https://github.com/dollspace-gay/Tesseract-Vault)
* **Adversarial Scanner:** [CodeScanner](https://github.com/dollspace-gay/codescanner) — AI-powered security analysis tool
* **Kani Harnesses:** [`src/config_kani.rs`](https://github.com/dollspace-gay/Tesseract-Vault/blob/main/src/config_kani.rs), [`src/crypto/streaming.rs`](https://github.com/dollspace-gay/Tesseract-Vault/blob/main/src/crypto/streaming.rs)
* **Wycheproof Tests:** [`tests/wycheproof_tests.rs`](https://github.com/dollspace-gay/Tesseract-Vault/blob/main/tests/wycheproof_tests.rs)
* **NIST PQC Tests:** [`tests/nist_pqc_tests.rs`](https://github.com/dollspace-gay/Tesseract-Vault/blob/main/tests/nist_pqc_tests.rs)
* **CI Workflows:** [`.github/workflows/`](https://github.com/dollspace-gay/Tesseract-Vault/tree/main/.github/workflows)
* **Security Reports:** [`security-reports/`](https://github.com/dollspace-gay/Tesseract-Vault/tree/main/security-reports) — Historical adversarial loop audit reports

---

## **Appendix A: Dependency Versions**

| Crate | Version | Purpose |
|-------|---------|---------|
| `aes-gcm` | 0.11.0-rc.2 | Authenticated encryption |
| `argon2` | 0.6.0-rc.2 | Password hashing |
| `ml-kem` | 0.3.0-pre.2 | Post-quantum KEM |
| `ml-dsa` | 0.1.0-rc.2 | Post-quantum signatures |
| `xts-mode` | 0.5 | Volume encryption |
| `blake3` | 1.5 | Fast hashing |
| `hmac` | 0.11 | AWS SigV4 signing |
| `sha2` | 0.9 | SHA-256 hashing |
| `hkdf` | 0.11 | Key derivation |
| `zeroize` | 1.8 | Secure memory scrubbing |
| `subtle` | 2.6 | Constant-time operations |

---

## **Appendix B: Security Properties Proven**

1. **No Nonce Reuse:** For any two distinct chunk indices i ≠ j, nonce(i) ≠ nonce(j)
2. **No Integer Overflow:** All arithmetic in cryptographic paths is checked
3. **No Panic Paths:** Verified code paths cannot panic on any input
4. **No Buffer Overflows:** Array bounds are statically verified
5. **Constant-Time Comparison:** Password/key comparisons show no timing variation
6. **Memory Scrubbing:** Sensitive data is provably zeroed on deallocation
