# Security Vulnerability Report

**Target:** `C:\Users\texas\Tesseract\Tesseract\src`
**Scan Date:** 2026-01-05 15:51:05
**Files Scanned:** 82
**Scan Duration:** 630.48 seconds

---

## Executive Summary

ðŸ”´ **Overall Risk Level: CRITICAL**

The security scan identified **21 potential vulnerabilities** in the codebase:

| Severity | Count |
|----------|-------|
| ðŸ”´ Critical | 1 |
| ðŸŸ  High | 7 |
| ðŸŸ¡ Medium | 8 |
| ðŸŸ¢ Low | 5 |
| âšª Info | 0 |

**Immediate action recommended for 8 critical/high severity issues.**

## Scan Statistics

### Findings by Tool
| Tool | Findings |
|------|----------|
| gemini-ai | 21 |

### Top CWE Categories
| CWE | Count | Description |
|-----|-------|-------------|
| CWE-312 | 4 | Security Weakness |
| CWE-327 | 2 | Broken Cryptography |
| CWE-22 | 2 | Path Traversal |
| CWE-276 | 1 | Security Weakness |
| CWE-532 | 1 | Security Weakness |


## Findings by Severity

### ðŸ”´ Critical (1)

#### 1. Missing Access Control on IPC Interface

- **Location:** `daemon\server.rs` (line 115)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-276

**Description:**
The daemon exposes sensitive functionality (mounting encrypted volumes, handling passwords) via IPC but lacks sufficient access controls:
1. On Unix (Line 115): The `UnixListener` is bound without explicitly setting file permissions (e.g., `0o600`). Depending on the user's `umask`, the socket file in `/tmp` or `XDG_RUNTIME_DIR` may be writable by other users on the system.
2. On Windows (Line 160): The daemon binds a TCP listener to `127.0.0.1`. Any user on the local machine can connect to this port.
3. The protocol (Line 285) processes commands immediately upon connection without requiring an authentication token or checking the peer's credentials (UID/GID).
This allows any local user to connect, mount volumes (if they have the password), unmount existing volumes, or shut down the daemon.

**Remediation:**
1. On Unix: Use `std::os::unix::fs::PermissionsExt` to set the socket file permissions to `0o600` (read/write only by owner) immediately after binding. Alternatively, check `SO_PEERCRED` upon connection to verify the client's UID matches the daemon's UID.
2. On Windows: Use Named Pipes with explicit Access Control Lists (ACLs) restricting access to the specific user/admin, rather than a TCP socket.
3. Implement an authentication handshake or shared secret validation at the start of the connection.

### ðŸŸ  High (7)

#### 1. Sensitive Data Exposure via Default Debug Implementation

- **Location:** `daemon\protocol.rs` (line 11)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-532

**Description:**
The `DaemonCommand` enum derives the `Debug` trait automatically (Line 11). The `Mount` variant (Lines 14-27) contains sensitive fields `password` and `hidden_password`. If the application logs incoming commands using the standard debug formatter `{:?}` (a common practice for debugging or auditing IPC traffic), the plaintext passwords will be written to the logs or console, leading to credential leakage.

**Remediation:**
Remove `Debug` from the derive macro. Implement `std::fmt::Debug` manually for `DaemonCommand` to explicitly redact the `password` and `hidden_password` fields (e.g., printing `"<REDACTED>"` instead of the value). Alternatively, use a wrapper type for these fields that handles secure debug formatting, such as `SecretString` from the `secrecy` crate.

#### 2. Denial of Service via Unbounded Memory Allocation

- **Location:** `daemon\server.rs` (lines 277-281)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-770

**Description:**
The `handle_client_impl` function reads a 4-byte integer from the stream to determine the message length and immediately allocates a vector of that size (`vec![0u8; len]`). The code does not validate this length against a maximum limit. A malicious client can send a packet indicating a very large size (e.g., 4GB), causing the server to attempt a massive allocation, leading to an Out-Of-Memory (OOM) crash and Denial of Service.

**Remediation:**
Implement a maximum message size limit (e.g., 1MB or 16MB) before allocating memory.
```rust
const MAX_MSG_SIZE: usize = 1024 * 1024 * 16; // 16MB
if len > MAX_MSG_SIZE {
    return Err("Message too large".into());
}
let mut buffer = vec![0u8; len];
```

#### 3. Sensitive Data Exposure in Memory

- **Location:** `daemon\server.rs` (line 334)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-312

**Description:**
The `process_command` function handles sensitive data (`password` and `hidden_password`) using standard Rust types (implied by the usage in `MountOptions`). When these variables are moved into the `MountOptions` struct or passed to `mgr.mount`, copies may be created on the heap. Standard `String` or `Vec` types do not zero out their memory when dropped. Consequently, plaintext passwords may persist in process memory, making them vulnerable to memory dump attacks or leakage to swap files.

**Remediation:**
Use a secure memory handling crate like `secrecy` or `zeroize`. Ensure that `DaemonCommand`, `MountOptions`, and the `VolumeManager` use types like `SecretString` or `Zeroizing<String>` for password fields, ensuring memory is scrubbed immediately after use.

#### 4. Use of Weak XOR Encryption

- **Location:** `hsm\tpm_utils.rs` (lines 356-361)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-327

**Description:**
The function `xor_encrypt_decrypt` implements a simple XOR cipher (effectively a VigenÃ¨re cipher) using a repeating 32-byte key. This algorithm is cryptographically broken and unsuitable for securing sensitive data.
1. **Key Reuse:** If the data exceeds 32 bytes, the key repeats, allowing trivial decryption via frequency analysis.
2. **Malleability:** XOR encryption provides no integrity protection. An attacker can flip bits in the ciphertext to predictably alter the plaintext without knowing the key.
3. **Known-Plaintext Attacks:** If an attacker knows part of the plaintext, they can trivially recover the key stream.

**Remediation:**
Replace the XOR logic with a standard, authenticated encryption algorithm such as AES-GCM (e.g., using the `aes-gcm` crate) or ChaCha20-Poly1305. Ensure a unique nonce is used for every encryption operation.

#### 5. Time-of-Check Time-of-Use (TOCTOU) Race Condition in Mount Operation

- **Location:** `volume\manager.rs` (lines 214-283)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-367

**Description:**
The `mount` function exhibits a race condition. It acquires a lock to check if a volume is already mounted (lines 214-229), releases the lock to perform time-consuming operations (`Container::open` and `mount`), and then re-acquires the lock to insert the new volume (line 283).
Between releasing the lock at line 229 and re-acquiring it at line 283, another thread could have successfully mounted the same container or used the same mount point. The code blindly inserts the new `ManagedVolume` into the map (`self.mounted.lock().unwrap().insert(...)`), potentially overwriting an existing entry. This violates the module's guarantee of preventing double-mounting and could lead to data corruption or inconsistent state where a volume is mounted physically but not tracked correctly by the manager.

**Remediation:**
1. Re-check the `mounted` map for the existence of `container_path` and `mount_point` immediately after re-acquiring the lock at line 283, before insertion.
2. Alternatively, insert a "pending" placeholder state into the map during the first lock acquisition to reserve the path/mount-point while the heavy lifting is performed outside the lock.

#### 6. Uncontrolled Memory Leak in CSP Generation

- **Location:** `wasm\security.rs` (line 125)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-401

**Description:**
The function `generate_csp_header` intentionally leaks memory using `Box::leak` to convert a `String` into a `&'static str`. This is done to satisfy the type inference of the `script_src` vector (which contains string literals). Since this is a public function that can be called repeatedly with user input (`additional_sources`), it creates a permanent memory leak for every call. An attacker could trigger a Denial of Service (DoS) by repeatedly calling this function until the WASM instance runs out of memory.

**Remediation:**
Change the `script_src` vector to hold `String` instead of `&str`. This allows the vector to own the data without leaking memory.
Example fix:
```rust
let mut script_src: Vec<String> = vec!["'self'".to_string()];
// ...
if let Some(sources) = additional_sources {
    script_src.extend(sources);
}
```

#### 7. Path Traversal via Insufficient Path Normalization

- **Location:** `volume\mount\winfsp_utils.rs` (lines 139-148)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-22

**Description:**
The `normalize_path` function converts Windows paths to internal paths using simple string replacement (`replace('\\', "/")`). It does not resolve or sanitize directory traversal sequences (`..`). If an attacker supplies a path containing traversal sequences (e.g., `\..\..\windows\system32`), the function returns a path containing `..` (e.g., `/../../windows/system32`). If the consuming filesystem implementation appends this result to a root directory without further validation, it allows access to files outside the intended volume root.

**Remediation:**
Instead of string manipulation, use `std::path::Path::components()` to iterate over the path. Filter out `Component::ParentDir` (`..`) or resolve them logically against a root to ensure the resulting path never escapes the intended root directory.

### ðŸŸ¡ Medium (8)

#### 1. Insecure Memory Handling of Passwords

- **Location:** `daemon\protocol.rs` (line 20)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-312

**Description:**
The `password` and `hidden_password` fields are defined as standard `String` types. Rust's standard `String` does not zero out (wipe) its memory contents when the variable is dropped or when memory is reallocated. This means sensitive password data may persist in the process's memory heap after the command has been processed, making it vulnerable to extraction via core dumps, swap files, or memory scraping attacks. Additionally, the `Clone` derivation (Line 11) allows easy duplication of these secrets in memory.

**Remediation:**
Replace the `String` type for sensitive fields with a secure container that implements memory zeroing on drop (Zeroize). Recommended approaches include using the `secrecy` crate (e.g., `SecretString`) or the `zeroize` crate. Ensure that the serialization logic (required for the IPC protocol) is compatible with the chosen secure type, often requiring explicit exposure methods for the serialization step only.

#### 2. Denial of Service via Thread Exhaustion

- **Location:** `daemon\server.rs` (line 138)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-400

**Description:**
The server spawns a new OS thread (`std::thread::spawn`) for every incoming connection. There is no limit on the number of concurrent connections. A malicious client can rapidly open thousands of connections, causing the server to exhaust system thread limits or memory, leading to a crash or system instability.

**Remediation:**
Use a thread pool with a fixed maximum number of threads (e.g., using the `threadpool` crate) or switch to an asynchronous runtime (like `tokio` or `async-std`) to handle connections efficiently without 1:1 thread mapping.

#### 3. Timing Side-Channel in Constant-Time Comparison

- **Location:** `hsm\tpm_utils.rs` (lines 379-390)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-208

**Description:**
The `constant_time_compare` function is intended to prevent timing attacks, but it contains flaws that may leak information:
1. **Length Leakage:** The check `if a.len() != b.len() { return false; }` (Line 380) is not constant-time; it returns immediately if lengths differ, leaking the length of the secret `b` to an attacker controlling `a`.
2. **Compiler Optimization Risks:** Implementing constant-time logic in high-level Rust without compiler hints (like `core::hint::black_box` or volatile reads) is risky. The compiler may optimize the loop (e.g., vectorization or short-circuiting) in ways that re-introduce data-dependent timing variances.

**Remediation:**
Do not implement constant-time comparison manually. Use the `subtle` crate and its `ConstantTimeEq` trait, which is designed to prevent compiler optimizations that introduce timing side-channels. If a dependency cannot be added, ensure the length check is removed (assuming fixed-size secrets) or handled in constant time, and use `core::hint::black_box` on the accumulator.

#### 4. Insecure Handling of Sensitive Data (Passwords in Memory)

- **Location:** `volume\manager.rs` (line 205)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-312

**Description:**
The `mount` function accepts `password` as a `&str` and creates `String` copies (e.g., `mount_password`, `hidden_pwd`). Standard Rust `String` types do not zeroize their memory contents when dropped. Consequently, plaintext passwords may persist in the process heap memory after the function returns. If the application crashes and generates a core dump, or if the memory is swapped to disk, these credentials could be exposed.

**Remediation:**
1. Use a secure wrapper for sensitive data, such as the `secrecy` crate's `SecretString` or a custom type that implements the `Drop` trait to zeroize memory (using `zeroize` crate).
2. Avoid cloning passwords into standard `String` types.

#### 5. Path Canonicalization Bypass (Path Aliasing)

- **Location:** `volume\manager.rs` (lines 208-211)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-22

**Description:**
The code attempts to canonicalize the `container_path` but falls back to the raw input path if canonicalization fails (`unwrap_or_else`).
```rust
.unwrap_or_else(|_| container_path.as_ref().to_path_buf());
```
If an attacker provides a path that causes `canonicalize` to fail (e.g., due to temporary permission issues, symlink loops, or specific filesystem states) but `Container::open` still succeeds (via the raw path), the volume will be stored in the map under the raw path (e.g., `../vol.scv`). A subsequent attempt to mount the same volume using an absolute path (or a different relative path) might succeed because the map keys do not match, bypassing the "AlreadyMounted" check. This allows the same volume to be mounted multiple times.

**Remediation:**
Do not fall back to the raw path. If `canonicalize()` fails, the `mount` operation should return an error immediately. This ensures that the `VolumeManager` always tracks volumes by their unique, absolute filesystem path.

#### 6. Content Security Policy (CSP) Injection

- **Location:** `wasm\security.rs` (lines 123-129)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-116

**Description:**
The `generate_csp_header` function accepts `additional_sources` and appends them directly to the CSP string without validation or sanitization. If an attacker can control the input to this function (e.g., via configuration), they can inject a semicolon (`;`) to terminate the `script-src` directive and inject arbitrary CSP directives (e.g., `https://evil.com; script-src 'unsafe-inline' *`). This defeats the purpose of the CSP generator.

**Remediation:**
Validate that strings in `additional_sources` do not contain semicolons, newlines, or other control characters before adding them to the directive list. Return an error if invalid characters are detected.

#### 7. Use of `eval` in Security Feature Check

- **Location:** `wasm\security.rs` (line 241)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-95

**Description:**
The function `check_security_features` uses `js_sys::eval("typeof Worker !== 'undefined'")` to check for Web Worker support. While the input string is constant, relying on `eval` is a security anti-pattern. Crucially, this function will fail (throw an exception) if the application has a strict Content Security Policy that forbids `'unsafe-eval'`. This forces developers to weaken their CSP (enabling `'unsafe-eval'`) just to run this security check, which contradicts the library's purpose of hardening security.

**Remediation:**
Replace the usage of `eval` with safe reflection APIs provided by `js_sys` and `wasm_bindgen`.
Example fix:
```rust
let global = js_sys::global();
let worker_available = js_sys::Reflect::get(&global, &JsValue::from("Worker"))
    .map(|v| !v.is_undefined())
    .unwrap_or(false);
```

#### 8. Unquoted Search Path in Desktop Entry

- **Location:** `bin\register\linux.rs` (line 90)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-428

**Description:**
The code constructs the `Exec` field of the `.desktop` file by directly formatting the `gui_exe` path without enclosing quotes. If the installation path contains spaces (e.g., `/home/user/My Apps/tesseract`), the desktop environment may interpret the path as an executable `/home/user/My` with arguments `Apps/tesseract`. This creates an "Unquoted Search Path" vulnerability where a malicious binary placed at the truncated path could be executed instead of the intended application.

**Remediation:**
Enclose the executable path in double quotes within the format string. Change line 90 to: `Exec="{}" %f`

### ðŸŸ¢ Low (5)

#### 1. Insecure Memory Handling for Decrypted Plaintext

- **Location:** `crypto\mod.rs` (line 59)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-312

**Description:**
The `decrypt` method in the `Encryptor` trait is defined to return `Result<Vec<u8>>`. Unlike the `KeyDerivation::derive_key` method (Line 79) which correctly uses `Zeroizing` to protect the generated key, the `decrypt` method returns a standard vector. This means that sensitive decrypted plaintext will remain in heap memory until overwritten by the allocator, potentially exposing secrets to memory scraping, core dumps, or swap file analysis. In the context of a "Vault" application, plaintext should be treated with the same memory hygiene as keys.

**Remediation:**
Modify the `decrypt` trait definition to return `Result<Zeroizing<Vec<u8>>>` (or a custom secure container) to ensure that sensitive plaintext is automatically zeroed out from memory when the vector is dropped.

#### 2. Hardcoded TCP Port (Windows)

- **Location:** `daemon\server.rs` (line 92)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-798

**Description:**
The Windows implementation uses a hardcoded TCP port (`37284`). If this port is already in use by another application, the daemon will fail to start. Furthermore, if a malicious application binds to this port before the daemon starts, it could potentially intercept local traffic intended for the daemon (though the daemon acts as the server, this creates a race condition for the resource).

**Remediation:**
Allow the port to be configurable via arguments or a configuration file. Ideally, switch to Windows Named Pipes for IPC, which avoids port conflicts and offers better security controls.

#### 3. Use of Non-Standard Hash Algorithm for TPM Policy

- **Location:** `hsm\tpm_utils.rs` (lines 306-324)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-327

**Description:**
The function `compute_policy_digest` uses the `blake3` hash algorithm to calculate a policy digest from PCR values. TPM 2.0 hardware and specifications typically use SHA-256 (or SHA-1/SHA-384) for PolicyPCR calculations.
While BLAKE3 is cryptographically strong, using it here creates a mismatch between the software-derived digest and the digest the actual TPM hardware will calculate internally. This will likely result in a functional failure (Denial of Service) where the TPM rejects the policy, or it implies a custom wrapper protocol that may not be interoperable with standard TPM tools.

**Remediation:**
If this function is intended to replicate TPM 2.0 `TPM2_PolicyPCR` behavior, change the hashing algorithm to match the bank being used (typically SHA-256). If this is a custom KDF unrelated to TPM hardware enforcement, document this deviation clearly to prevent misuse in security-critical TPM contexts.

#### 4. Insecure File Permissions on Desktop Entry

- **Location:** `bin\register\linux.rs` (line 109)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-732

**Description:**
The code explicitly sets the permissions of the generated `.desktop` file to `0o755` (rwxr-xr-x). `.desktop` files are configuration files used by the desktop environment to launch applications; they are not binaries themselves. Granting execute permissions is unnecessary and can be flagged as a security risk by some desktop environments (treating the file as a shell script). Furthermore, it grants execute permission to all users on the system, which violates the principle of least privilege.

**Remediation:**
Change the permission mode to `0o644` (rw-r--r--) to allow read/write by the owner and read-only by others, or `0o600` (rw-------) for strictly local access. Remove the executable bit.

#### 5. Integer Overflow in Timestamp Conversion

- **Location:** `volume\mount\winfsp_utils.rs` (line 83)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-190

**Description:**
The function `unix_to_filetime` performs arithmetic operations (`unix_time * TICKS_PER_SECOND`) without overflow checks. While valid dates are unlikely to overflow `u64`, malicious input (a very large `unix_time`) could cause an integer overflow. In Rust debug builds, this results in a panic (Denial of Service). In release builds, this wraps, resulting in an incorrect FILETIME value which could lead to logic errors in time-dependent filesystem operations.

**Remediation:**
Use `checked_mul` and `checked_add` to perform the calculation. Return a `Result` or clamp the value to `u64::MAX` (or a valid maximum FILETIME) if an overflow would occur.

## Findings by File

### `bin\register\linux.rs` (1 medium, 1 low)
- [MEDIUM] Unquoted Search Path in Desktop Entry L90
- [LOW] Insecure File Permissions on Desktop Entry L109

### `crypto\mod.rs` (1 low)
- [LOW] Insecure Memory Handling for Decrypted Plaintext L59

### `daemon\protocol.rs` (1 high, 1 medium)
- [HIGH] Sensitive Data Exposure via Default Debug Implementation L11
- [MEDIUM] Insecure Memory Handling of Passwords L20

### `daemon\server.rs` (1 critical, 2 high, 1 medium, 1 low)
- [CRITICAL] Missing Access Control on IPC Interface L115
- [HIGH] Denial of Service via Unbounded Memory Allocation L277
- [HIGH] Sensitive Data Exposure in Memory L334
- [MEDIUM] Denial of Service via Thread Exhaustion L138
- [LOW] Hardcoded TCP Port (Windows) L92

### `hsm\tpm_utils.rs` (1 high, 1 medium, 1 low)
- [HIGH] Use of Weak XOR Encryption L356
- [MEDIUM] Timing Side-Channel in Constant-Time Comparison L379
- [LOW] Use of Non-Standard Hash Algorithm for TPM Policy L306

### `volume\manager.rs` (1 high, 2 medium)
- [HIGH] Time-of-Check Time-of-Use (TOCTOU) Race Condition in Mount Operation L214
- [MEDIUM] Insecure Handling of Sensitive Data (Passwords in Memory) L205
- [MEDIUM] Path Canonicalization Bypass (Path Aliasing) L208

### `volume\mount\winfsp_utils.rs` (1 high, 1 low)
- [HIGH] Path Traversal via Insufficient Path Normalization L139
- [LOW] Integer Overflow in Timestamp Conversion L83

### `wasm\security.rs` (1 high, 2 medium)
- [HIGH] Uncontrolled Memory Leak in CSP Generation L125
- [MEDIUM] Content Security Policy (CSP) Injection L123
- [MEDIUM] Use of `eval` in Security Feature Check L241

## Tools Used

| Tool | Description |
|------|-------------|
| Bandit | Python security linter - detects common security issues |
| Semgrep | Multi-language static analysis with security rulesets |
| Safety | Python dependency vulnerability scanner |
| Gemini AI | AI-powered code analysis using Gemini 3 Pro |

---

*Report generated by CodeScanner on 2026-01-05 15:51:05*

**Disclaimer:** This automated scan may produce false positives or miss certain vulnerabilities.
Manual security review is recommended for critical applications.