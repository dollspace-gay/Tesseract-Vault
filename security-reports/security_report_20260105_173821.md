# Security Vulnerability Report

**Target:** `C:\Users\texas\Tesseract\Tesseract\src`
**Scan Date:** 2026-01-05 17:38:30
**Files Scanned:** 83
**Scan Duration:** 417.09 seconds

---

## Executive Summary

ðŸŸ  **Overall Risk Level: HIGH**

The security scan identified **12 potential vulnerabilities** in the codebase:

| Severity | Count |
|----------|-------|
| ðŸ”´ Critical | 0 |
| ðŸŸ  High | 5 |
| ðŸŸ¡ Medium | 4 |
| ðŸŸ¢ Low | 3 |
| âšª Info | 0 |

**Immediate action recommended for 5 critical/high severity issues.**

## Scan Statistics

### Findings by Tool
| Tool | Findings |
|------|----------|
| gemini-ai | 12 |

### Top CWE Categories
| CWE | Count | Description |
|-----|-------|-------------|
| CWE-312 | 3 | Security Weakness |
| CWE-377 | 2 | Insecure Temp File |
| CWE-770 | 2 | Security Weakness |
| CWE-367 | 1 | Security Weakness |
| CWE-284 | 1 | Security Weakness |


## Findings by Severity

### ðŸŸ  High (5)

#### 1. Race Condition in Windows File Permissions (TOCTOU)

- **Location:** `daemon\auth.rs` (lines 142-153)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-367

**Description:**
On Windows, the code creates the token file, writes the sensitive token data, and *then* attempts to restrict permissions using `icacls`. There is a time window between the file creation (lines 142-146) and the permission application (line 152) where the file exists with default permissions (often readable by other users if in a shared directory like `C:\Windows\Temp` or `ProgramData`). A malicious local user could open the file and read the token during this window.

**Remediation:**
The file must be created with restricted permissions atomically. On Windows, this requires using the `OpenOptionsExt` trait with `security_attributes` or using low-level Windows APIs (via crates like `windows-sys` or `winapi`) to pass a `SECURITY_ATTRIBUTES` structure containing a DACL that restricts access to the owner during the `CreateFile` call. Alternatively, create a directory with restricted permissions first, then create the file inside it.

#### 2. Insecure Temporary File Creation (Symlink Attack)

- **Location:** `daemon\auth.rs` (line 89)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-377

**Description:**
When `XDG_RUNTIME_DIR` is not set on Unix, the code falls back to `/tmp/tesseract-daemon.token`. Since `/tmp` is a world-writable directory and the filename is predictable, a malicious user can pre-create this file or create a symbolic link at this path pointing to a sensitive file owned by the user running the daemon (e.g., `~/.ssh/id_rsa`).
The `OpenOptions` configuration uses `create(true)` and `truncate(true)` but does not specify `O_NOFOLLOW` (which is not exposed directly in standard `OpenOptions`). If the path is a symlink, the daemon will overwrite the target of the link with the token, leading to data destruction or denial of service.

**Remediation:**
1. Avoid using a fixed filename in `/tmp`. Create a directory with a random name inside `/tmp` using `mkdtemp` logic, set its permissions to `0700`, and store the token file inside that directory.
2. If a fixed path is required, use `O_NOFOLLOW` (via `libc` or `nix` crate) when opening the file to ensure it is not a symlink.
3. Verify the file does not exist before creating it (using `O_EXCL` / `create_new(true)`), though this requires handling the case where the daemon restarts.

#### 3. Uncontrolled Memory Allocation (Potential Denial of Service)

- **Location:** `daemon\client.rs` (lines 158-160)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-770

**Description:**
The client reads a 4-byte integer (`len`) from the stream and immediately allocates a vector of that size (`vec![0u8; len]`) without validation. If a malicious server or a Man-in-the-Middle (MitM) attacker sends a large value (e.g., `0xFFFFFFFF`), the client will attempt to allocate 4GB of memory, likely causing the application to crash (OOM) or hang.

**Remediation:**
Implement a maximum limit for the response size before allocation.
```rust
const MAX_RESPONSE_SIZE: usize = 10 * 1024 * 1024; // e.g., 10MB
if len > MAX_RESPONSE_SIZE {
    return Err("Response too large".into());
}
let mut buffer = vec![0u8; len];
```

#### 4. Insecure Default Socket Path in Shared Directory

- **Location:** `daemon\client.rs` (line 65)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-377

**Description:**
On Unix-like systems, if `XDG_RUNTIME_DIR` is not set, the client falls back to `/tmp/tesseract-daemon.sock`. The `/tmp` directory is typically world-writable. A local attacker could create this socket file before the daemon starts (or if the daemon is down). When the client connects to this attacker-controlled socket, it immediately transmits the authentication token (Line 142-152), leading to privilege escalation.

**Remediation:**
Avoid using `/tmp` for the socket file. Fall back to a user-specific directory with restricted permissions, such as `~/.tesseract/` or `~/.local/share/tesseract/`. If `/tmp` must be used, the directory containing the socket must be created with strict permissions (`0700`) and owned by the user.

#### 5. Sensitive Data Stored in Non-Zeroizing Memory

- **Location:** `daemon\protocol.rs` (line 28)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-312

**Description:**
The `AuthenticatedRequest` and `DaemonCommand` structs use standard Rust `String` types to store sensitive information, specifically `auth_token` (line 28), `password` (line 75), and `hidden_password` (line 81). Standard `String` types do not zeroize (overwrite with zeros) their memory contents when the variable is dropped or reallocated. Consequently, plaintext passwords and authentication tokens may persist in process memory, swap files, or core dumps after they are no longer needed, allowing local attackers with memory access or file access to recover them.

**Remediation:**
Replace `String` fields for sensitive data with types that ensure memory is zeroed upon destruction. Use the `secrecy` crate (e.g., `SecretString`) or the `zeroize` crate (e.g., `Zeroizing<String>`). This ensures that sensitive data is scrubbed from memory immediately when it goes out of scope.

### ðŸŸ¡ Medium (4)

#### 1. Authorization Bypass via Environment Variable Spoofing

- **Location:** `daemon\auth.rs` (line 175)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-284

**Description:**
The Windows permission logic relies on the `USERNAME` environment variable to determine who should be granted access to the token file (`format!("{}:F", username)`). Environment variables are untrusted input and can be manipulated by the user launching the process.
If a malicious user can influence the environment variables of the daemon (e.g., in a shared hosting environment or via a compromised parent process), they could set `USERNAME` to `Everyone` or another user, causing `icacls` to grant incorrect permissions to the token file.

**Remediation:**
Do not rely on environment variables for security decisions. Programmatically determine the current user's Security Identifier (SID) or username using Windows APIs (e.g., `GetUserNameW` or `GetTokenInformation`) to ensure the permissions are granted to the actual owner of the process.

#### 2. Sensitive Data Stored in Non-Zeroizing Memory

- **Location:** `daemon\client.rs` (line 28)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-312

**Description:**
The `DaemonClient` stores the `auth_token` as a standard `String`. Additionally, the `mount` method accepts `password` and `hidden_password` as `String`. Standard Rust `String` types do not zero out their memory when dropped. This leaves sensitive credentials in the heap, which could be exposed via core dumps, swap files, or memory inspection attacks.

**Remediation:**
Use a crate designed for secure memory handling, such as `secrecy` (using `SecretString`) or `zeroize`.
```rust
// Example using secrecy
use secrecy::{SecretString, ExposeSecret};

pub struct DaemonClient {
    // ...
    auth_token: Option<SecretString>,
}

pub fn mount(..., password: SecretString, ...) { ... }
```

#### 3. Lack of Server Identity Verification

- **Location:** `daemon\client.rs` (line 120)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-287

**Description:**
The client connects to a local socket (Unix) or TCP port (Windows) and immediately sends the authentication token (Line 142-152) without verifying the identity of the server.
1. On Windows (Line 130), any local user can bind to port 37284 if the daemon is not running.
2. On Unix (Line 120), if the socket path is in a writable location (see previous vulnerability), it can be spoofed.
If an attacker spoofs the server, the client will leak the valid auth token to the attacker.

**Remediation:**
1. **Windows:** Ensure the daemon binds exclusively or use Windows Named Pipes with ACLs instead of TCP localhost, as TCP localhost does not provide user-based access controls.
2. **Unix:** Verify the owner/permissions of the socket file (`std::os::unix::fs::MetadataExt`) before writing data to the stream to ensure it is owned by the expected user (or root).

#### 4. Unbounded Memory Allocation in File Read

- **Location:** `storage\mod.rs` (lines 44-48)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-770

**Description:**
The `read_file` function reads the entire contents of a file into a `Vec<u8>` using `read_to_end` without checking the file size or enforcing a limit. If an attacker can control the file path (e.g., pointing to a very large file or a zero-stream device like `/dev/zero` on Linux), this will cause the application to allocate excessive memory, leading to an Out-Of-Memory (OOM) crash and Denial of Service.

**Remediation:**
Implement a maximum size limit for the read operation. Check the file metadata size before reading, or use `File::open(path)?.take(MAX_SIZE).read_to_end(&mut data)?` to ensure memory usage remains within safe bounds.

### ðŸŸ¢ Low (3)

#### 1. Sensitive Token Persists in Memory

- **Location:** `daemon\auth.rs` (line 46)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-312

**Description:**
The authentication token is stored as a standard `String` in the `AuthManager` struct. Rust's default `String` does not zero out its memory when dropped. If the daemon process crashes and generates a core dump, or if the memory is swapped to disk, the plaintext token could be recovered by an attacker with access to the dump or swap file.

**Remediation:**
Use a secure memory handling crate like `secrecy` (using `SecretString`) or `zeroize`. Implement the `Drop` trait to explicitly overwrite the memory containing the token with zeros before deallocating it.

#### 2. Auth Token Type Encourages Timing Attacks

- **Location:** `daemon\protocol.rs` (line 28)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-208

**Description:**
The `auth_token` is defined as a `String`. When the daemon compares the received token against the expected token, using standard string equality (`==`) results in a non-constant time comparison (the operation returns as soon as a byte mismatch is found). This exposes the application to timing attacks where an attacker can guess the token byte-by-byte by measuring the response time. While the comparison logic is not in this file, defining the field as a `String` rather than a byte array or a dedicated secret type encourages insecure comparison methods.

**Remediation:**
Define the `auth_token` as a fixed-size byte array (e.g., `[u8; 32]` if decoding hex, or a wrapper type) and document or enforce the use of constant-time comparison functions (such as those provided by the `subtle` crate or `openssl::memcmp`) when validating the token.

#### 3. Integer Truncation in Salt Length Serialization

- **Location:** `storage\mod.rs` (line 136)
- **Tool:** gemini-ai
- **Confidence:** medium
- **CWE:** CWE-197

**Description:**
The code casts the length of the salt string (`usize`) directly to `u8` (`salt_str.len() as u8`) without validating that the length fits within a byte (0-255). While `argon2` salts are typically short, `SaltString` can technically hold longer values. If a salt longer than 255 bytes is provided, the length will wrap around (truncate), resulting in a corrupted file structure. The reader will subsequently read an incorrect salt length and misinterpret the remaining salt bytes as the nonce/ciphertext.

**Remediation:**
Add an explicit check before the cast to ensure `salt_str.len()` is less than or equal to `u8::MAX` (or `MAX_SALT_LEN` if defined to be <= 255). Return a `CryptorError` if the salt is too long.

## Findings by File

### `daemon\auth.rs` (2 high, 1 medium, 1 low)
- [HIGH] Race Condition in Windows File Permissions (TOCTOU) L142
- [HIGH] Insecure Temporary File Creation (Symlink Attack) L89
- [MEDIUM] Authorization Bypass via Environment Variable Spoofing L175
- [LOW] Sensitive Token Persists in Memory L46

### `daemon\client.rs` (2 high, 2 medium)
- [HIGH] Uncontrolled Memory Allocation (Potential Denial of Service) L158
- [HIGH] Insecure Default Socket Path in Shared Directory L65
- [MEDIUM] Sensitive Data Stored in Non-Zeroizing Memory L28
- [MEDIUM] Lack of Server Identity Verification L120

### `daemon\protocol.rs` (1 high, 1 low)
- [HIGH] Sensitive Data Stored in Non-Zeroizing Memory L28
- [LOW] Auth Token Type Encourages Timing Attacks L28

### `storage\mod.rs` (1 medium, 1 low)
- [MEDIUM] Unbounded Memory Allocation in File Read L44
- [LOW] Integer Truncation in Salt Length Serialization L136

## Tools Used

| Tool | Description |
|------|-------------|
| Bandit | Python security linter - detects common security issues |
| Semgrep | Multi-language static analysis with security rulesets |
| Safety | Python dependency vulnerability scanner |
| Gemini AI | AI-powered code analysis using Gemini 3 Pro |

---

*Report generated by CodeScanner on 2026-01-05 17:38:30*

**Disclaimer:** This automated scan may produce false positives or miss certain vulnerabilities.
Manual security review is recommended for critical applications.