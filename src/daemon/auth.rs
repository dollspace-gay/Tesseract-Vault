// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2024 Tesseract Vault Contributors
//! Authentication module for daemon IPC
//!
//! Provides token-based authentication to ensure only authorized processes
//! can communicate with the daemon.
//!
//! # Security Model
//!
//! When the daemon starts, it generates a cryptographically random token and
//! saves it to a file that is only readable by the current user. Clients must
//! read this token and include it with every request.
//!
//! This prevents other local users from sending commands to the daemon.

use std::fs::{self, File, OpenOptions};
use std::io::{Read, Write};
use std::path::PathBuf;
use thiserror::Error;
use zeroize::Zeroize;

use super::protocol::AUTH_TOKEN_LENGTH;

/// Errors that can occur during authentication operations
#[derive(Debug, Error)]
pub enum AuthError {
    /// Failed to generate random token
    #[error("Failed to generate random token: {0}")]
    RandomGeneration(String),

    /// Failed to create or access token file
    #[error("Token file error: {0}")]
    TokenFile(#[from] std::io::Error),

    /// Invalid token format
    #[error("Invalid token format: {0}")]
    InvalidFormat(String),

    /// Token validation failed
    #[error("Authentication failed: invalid token")]
    InvalidToken,
}

/// Authentication manager for the daemon
///
/// # Security
///
/// The Drop implementation zeroizes the token from memory before cleanup (CWE-316 mitigation).
pub struct AuthManager {
    /// The authentication token (hex-encoded)
    token: String,
    /// Path to the token file
    token_path: PathBuf,
}

impl AuthManager {
    /// Create a new auth manager, generating a fresh token
    ///
    /// This will:
    /// 1. Generate a cryptographically random token
    /// 2. Save it to a file with restricted permissions
    ///
    /// # Returns
    ///
    /// A new AuthManager instance
    pub fn new() -> Result<Self, AuthError> {
        let token_path = Self::default_token_path();
        let token = Self::generate_token()?;

        let manager = Self { token, token_path };
        manager.save_token()?;

        Ok(manager)
    }

    /// Create an auth manager that loads an existing token
    ///
    /// This is used by clients to read the token generated by the daemon.
    pub fn load() -> Result<Self, AuthError> {
        let token_path = Self::default_token_path();
        let token = Self::read_token_from_file(&token_path)?;

        Ok(Self { token, token_path })
    }

    /// Get the default token file path
    fn default_token_path() -> PathBuf {
        #[cfg(unix)]
        {
            // Use XDG_RUNTIME_DIR if available (preferred - per-session, auto-cleaned)
            // Otherwise fall back to XDG_DATA_HOME or ~/.local/share/tesseract
            // Avoid /tmp to prevent symlink attacks and world-readable concerns
            if let Ok(runtime_dir) = std::env::var("XDG_RUNTIME_DIR") {
                let dir = PathBuf::from(runtime_dir).join("tesseract");
                let _ = fs::create_dir_all(&dir);
                dir.join("daemon.token")
            } else if let Ok(data_home) = std::env::var("XDG_DATA_HOME") {
                let dir = PathBuf::from(data_home).join("tesseract");
                let _ = fs::create_dir_all(&dir);
                dir.join("daemon.token")
            } else if let Ok(home) = std::env::var("HOME") {
                let dir = PathBuf::from(home).join(".local/share/tesseract");
                let _ = fs::create_dir_all(&dir);
                dir.join("daemon.token")
            } else {
                // Last resort - this should rarely happen on Unix systems
                PathBuf::from("/tmp/tesseract-daemon.token")
            }
        }

        #[cfg(windows)]
        {
            // Use LOCALAPPDATA/Tesseract for Windows
            if let Ok(local_app_data) = std::env::var("LOCALAPPDATA") {
                let dir = PathBuf::from(local_app_data).join("Tesseract");
                // Create directory if it doesn't exist
                let _ = fs::create_dir_all(&dir);
                dir.join("daemon.token")
            } else {
                // Fallback to temp directory
                std::env::temp_dir().join("tesseract-daemon.token")
            }
        }
    }

    /// Generate a cryptographically random token
    fn generate_token() -> Result<String, AuthError> {
        let mut bytes = [0u8; AUTH_TOKEN_LENGTH];
        getrandom::fill(&mut bytes).map_err(|e| AuthError::RandomGeneration(e.to_string()))?;
        Ok(hex::encode(bytes))
    }

    /// Save the token to a file with restricted permissions
    fn save_token(&self) -> Result<(), AuthError> {
        // Ensure parent directory exists
        if let Some(parent) = self.token_path.parent() {
            fs::create_dir_all(parent)?;
        }

        #[cfg(unix)]
        {
            use std::os::unix::fs::OpenOptionsExt;

            // Check for symlink attacks - the path should not be a symlink
            if self.token_path.is_symlink() {
                return Err(AuthError::TokenFile(std::io::Error::new(
                    std::io::ErrorKind::InvalidInput,
                    "Token path is a symlink - possible attack detected",
                )));
            }

            // Create file with mode 0600 (owner read/write only)
            // Use create_new to fail if file already exists (prevents race)
            let file_result = OpenOptions::new()
                .write(true)
                .create_new(true)
                .mode(0o600)
                .open(&self.token_path);

            let mut file = match file_result {
                Ok(f) => f,
                Err(e) if e.kind() == std::io::ErrorKind::AlreadyExists => {
                    // File exists - remove it first, then create with secure perms
                    fs::remove_file(&self.token_path)?;
                    OpenOptions::new()
                        .write(true)
                        .create_new(true)
                        .mode(0o600)
                        .open(&self.token_path)?
                }
                Err(e) => return Err(e.into()),
            };

            file.write_all(self.token.as_bytes())?;
            file.sync_all()?;
        }

        #[cfg(windows)]
        {
            // On Windows, use a temporary file approach to avoid TOCTOU race:
            // 1. Write to temp file
            // 2. Set permissions on temp file
            // 3. Atomically rename to target

            let parent = self
                .token_path
                .parent()
                .unwrap_or(std::path::Path::new("."));
            let temp_name = format!("daemon.token.{}.tmp", std::process::id());
            let temp_path = parent.join(&temp_name);

            // Write to temporary file
            {
                let mut file = OpenOptions::new()
                    .write(true)
                    .create(true)
                    .truncate(true)
                    .open(&temp_path)?;

                file.write_all(self.token.as_bytes())?;
                file.sync_all()?;
            }

            // Set permissions on temp file (while it's not yet at final location)
            Self::set_windows_permissions(&temp_path)?;

            // Remove old token file if it exists
            let _ = fs::remove_file(&self.token_path);

            // Atomically rename temp file to final location
            fs::rename(&temp_path, &self.token_path).inspect_err(|_| {
                // Clean up temp file on failure
                let _ = fs::remove_file(&temp_path);
            })?;
        }

        Ok(())
    }

    /// Set Windows file permissions to owner-only access
    ///
    /// This is a best-effort operation - if it fails, we log a warning but continue.
    /// On single-user systems, the default permissions are usually sufficient.
    #[cfg(windows)]
    fn set_windows_permissions(path: &PathBuf) -> Result<(), AuthError> {
        use std::process::Command;

        // Verify file exists before trying to set permissions
        if !path.exists() {
            return Ok(()); // File doesn't exist yet, skip permissions
        }

        // Use icacls to set permissions:
        // /inheritance:r - Remove inherited permissions
        // /grant:r - Grant explicit permissions
        // <username>:F - Full control to current user only
        //
        // SECURITY: Use GetUserNameW API instead of %USERNAME% env var to prevent
        // environment variable spoofing attacks (fixes CWE-807: Reliance on Untrusted Inputs)
        let username = match get_current_username_secure() {
            Some(name) => name,
            None => {
                // Can't determine username, skip permissions but don't fail
                eprintln!("WARNING: Could not determine username for setting file permissions");
                return Ok(());
            }
        };

        // First, remove inheritance and existing permissions
        let _ = Command::new("icacls")
            .arg(path)
            .arg("/inheritance:r")
            .output();
        // Ignore errors - file might not have inherited permissions

        // Grant full control to current user only
        match Command::new("icacls")
            .arg(path)
            .arg("/grant:r")
            .arg(format!("{}:F", username))
            .output()
        {
            Ok(output) if !output.status.success() => {
                // Log warning but don't fail - default permissions are often acceptable
                eprintln!(
                    "WARNING: Could not restrict token file permissions: {}",
                    String::from_utf8_lossy(&output.stderr)
                );
            }
            Err(e) => {
                eprintln!("WARNING: Could not run icacls: {}", e);
            }
            _ => {}
        }

        Ok(())
    }

    /// Computes HMAC-SHA256 for server identity verification
    ///
    /// The server uses this to prove its identity to the client by signing
    /// a challenge nonce with the auth token as the key.
    pub fn compute_server_identity_response(&self, challenge: &[u8; 32]) -> [u8; 32] {
        use blake3::Hasher;

        let mut hasher = Hasher::new_keyed(
            &hex::decode(&self.token)
                .unwrap_or_else(|_| vec![0u8; AUTH_TOKEN_LENGTH])
                .try_into()
                .unwrap_or([0u8; AUTH_TOKEN_LENGTH]),
        );
        hasher.update(challenge);
        hasher.update(b"tesseract-server-identity-v1");
        *hasher.finalize().as_bytes()
    }

    /// Verifies a server identity response
    ///
    /// The client uses this to verify that the server knows the auth token
    /// by checking the server's response to a challenge.
    pub fn verify_server_identity(
        &self,
        challenge: &[u8; 32],
        response: &[u8; 32],
    ) -> bool {
        use subtle::ConstantTimeEq;

        let expected = self.compute_server_identity_response(challenge);
        expected.ct_eq(response).into()
    }

    /// Read token from file
    fn read_token_from_file(path: &PathBuf) -> Result<String, AuthError> {
        let mut file = File::open(path)?;
        let mut token = String::new();
        file.read_to_string(&mut token)?;

        // Validate token format (should be hex-encoded)
        if token.len() != AUTH_TOKEN_LENGTH * 2 {
            return Err(AuthError::InvalidFormat(format!(
                "Expected {} hex characters, got {}",
                AUTH_TOKEN_LENGTH * 2,
                token.len()
            )));
        }

        if !token.chars().all(|c| c.is_ascii_hexdigit()) {
            return Err(AuthError::InvalidFormat(
                "Token contains non-hex characters".to_string(),
            ));
        }

        Ok(token)
    }

    /// Get the token value
    pub fn token(&self) -> &str {
        &self.token
    }

    /// Get the token file path
    pub fn token_path(&self) -> &PathBuf {
        &self.token_path
    }

    /// Validate a provided token against the stored token
    ///
    /// Uses constant-time comparison to prevent timing attacks.
    pub fn validate(&self, provided_token: &str) -> Result<(), AuthError> {
        use subtle::ConstantTimeEq;

        let stored_bytes = self.token.as_bytes();
        let provided_bytes = provided_token.as_bytes();

        // First check lengths (this is okay to leak)
        if stored_bytes.len() != provided_bytes.len() {
            return Err(AuthError::InvalidToken);
        }

        // Constant-time comparison
        if stored_bytes.ct_eq(provided_bytes).into() {
            Ok(())
        } else {
            Err(AuthError::InvalidToken)
        }
    }

    /// Remove the token file (called on daemon shutdown)
    pub fn cleanup(&self) -> Result<(), AuthError> {
        if self.token_path.exists() {
            fs::remove_file(&self.token_path)?;
        }
        Ok(())
    }
}

impl Drop for AuthManager {
    fn drop(&mut self) {
        // Securely zeroize the token from memory before cleanup (CWE-316)
        self.token.zeroize();
        // Best-effort file cleanup
        let _ = self.cleanup();
    }
}

/// Gets the current username securely using Windows API
///
/// This function uses the Windows GetUserNameW API instead of environment variables
/// to prevent environment variable spoofing attacks (CWE-807).
///
/// # Security
///
/// Environment variables like %USERNAME% can be spoofed by a malicious process
/// before launching Tesseract. The Windows API provides the actual username
/// from the process token, which cannot be spoofed without administrator privileges.
#[cfg(windows)]
fn get_current_username_secure() -> Option<String> {
    use std::ffi::OsString;
    use std::os::windows::ffi::OsStringExt;
    use windows::Win32::System::WindowsProgramming::GetUserNameW;
    use windows::core::PWSTR;

    // Initial buffer size (256 wide chars should be enough for most usernames)
    let mut buffer: Vec<u16> = vec![0; 256];
    let mut size = buffer.len() as u32;

    // GetUserNameW retrieves the username from the process token
    // This is secure because it queries the OS directly, not environment variables
    let result = unsafe {
        GetUserNameW(Some(PWSTR(buffer.as_mut_ptr())), &mut size)
    };

    match result {
        Ok(()) => {
            // Success - size now contains the length including null terminator
            // Truncate buffer to actual size (excluding null terminator)
            buffer.truncate((size.saturating_sub(1)) as usize);
            let os_string = OsString::from_wide(&buffer);
            os_string.into_string().ok()
        }
        Err(error) => {
            // Check if buffer was too small and retry
            if error.code().0 as u32 == windows::Win32::Foundation::ERROR_INSUFFICIENT_BUFFER.0 {
                buffer.resize(size as usize, 0);
                let retry_result = unsafe {
                    GetUserNameW(Some(PWSTR(buffer.as_mut_ptr())), &mut size)
                };
                if retry_result.is_ok() {
                    buffer.truncate((size.saturating_sub(1)) as usize);
                    let os_string = OsString::from_wide(&buffer);
                    return os_string.into_string().ok();
                }
            }
            None
        }
    }
}

/// Stub for non-Windows platforms (Linux uses file permissions via mode bits)
#[cfg(not(windows))]
fn get_current_username_secure() -> Option<String> {
    // On Unix, we use file mode bits (0o600) for permissions, not ACLs
    // So we don't need the username for permission setting
    None
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;

    fn temp_token_path() -> PathBuf {
        env::temp_dir().join(format!("test-token-{}.token", std::process::id()))
    }

    #[test]
    fn test_generate_token() {
        let token1 = AuthManager::generate_token().unwrap();
        let token2 = AuthManager::generate_token().unwrap();

        // Should be correct length
        assert_eq!(token1.len(), AUTH_TOKEN_LENGTH * 2);
        assert_eq!(token2.len(), AUTH_TOKEN_LENGTH * 2);

        // Should be hex-encoded
        assert!(token1.chars().all(|c| c.is_ascii_hexdigit()));
        assert!(token2.chars().all(|c| c.is_ascii_hexdigit()));

        // Should be unique
        assert_ne!(token1, token2);
    }

    #[test]
    fn test_validate_correct_token() {
        let manager = AuthManager {
            token: "a".repeat(AUTH_TOKEN_LENGTH * 2),
            token_path: temp_token_path(),
        };

        assert!(manager.validate(&"a".repeat(AUTH_TOKEN_LENGTH * 2)).is_ok());
    }

    #[test]
    fn test_validate_wrong_token() {
        let manager = AuthManager {
            token: "a".repeat(AUTH_TOKEN_LENGTH * 2),
            token_path: temp_token_path(),
        };

        assert!(manager
            .validate(&"b".repeat(AUTH_TOKEN_LENGTH * 2))
            .is_err());
    }

    #[test]
    fn test_validate_wrong_length() {
        let manager = AuthManager {
            token: "a".repeat(AUTH_TOKEN_LENGTH * 2),
            token_path: temp_token_path(),
        };

        assert!(manager.validate("too_short").is_err());
    }

    #[test]
    fn test_token_file_roundtrip() {
        // Use a unique path with timestamp to avoid conflicts
        let path = env::temp_dir().join(format!(
            "test-token-{}-{}.token",
            std::process::id(),
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos()
        ));
        let original_token = AuthManager::generate_token().unwrap();

        // Save token directly without using AuthManager (to avoid Drop cleanup)
        {
            let mut file = std::fs::OpenOptions::new()
                .write(true)
                .create(true)
                .truncate(true)
                .open(&path)
                .unwrap();
            file.write_all(original_token.as_bytes()).unwrap();
            file.sync_all().unwrap();
        }

        // Read back
        let loaded_token = AuthManager::read_token_from_file(&path).unwrap();
        assert_eq!(original_token, loaded_token);

        // Cleanup
        let _ = fs::remove_file(&path);
    }

    #[test]
    fn test_auth_error_display() {
        let err = AuthError::InvalidToken;
        assert!(err.to_string().contains("invalid token"));

        let err = AuthError::InvalidFormat("test".to_string());
        assert!(err.to_string().contains("test"));
    }
}
